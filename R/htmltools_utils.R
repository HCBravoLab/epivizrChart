## This file has function modified from htmltools and will be removed once the pull request is accepted. 

#' Define an HTML dependency
#'
#' Define an HTML dependency (i.e. CSS and/or JavaScript bundled in a
#' directory). HTML dependencies make it possible to use libraries like jQuery,
#' Bootstrap, and d3 in a more composable and portable way than simply using
#' script, link, and style tags.
#'
#' @param name Library name
#' @param version Library version
#' @param src Unnamed single-element character vector indicating the full path
#'   of the library directory. Alternatively, a named character string with one
#'   or more elements, indicating different places to find the library; see
#'   Details.
#' @param meta Named list of meta tags to insert into document head
#' @param script Script(s) to include within the document head (should be
#'   specified relative to the \code{src} parameter).
#' @param stylesheet Stylesheet(s) to include within the document (should be
#'   specified relative to the \code{src} parameter).
#' @param head Arbitrary lines of HTML to insert into the document head
#' @param attachment Attachment(s) to include within the document head. See
#'   Details.
#' @param package An R package name to indicate where to find the \code{src}
#'   directory when \code{src} is a relative path (see
#'   \code{\link{resolveDependencies}}).
#' @param all_files Whether all files under the \code{src} directory are
#'   dependency files. If \code{FALSE}, only the files specified in
#'   \code{script}, \code{stylesheet}, and \code{attachment} are treated as
#'   dependency files.
#'
#' @return An object that can be included in a list of dependencies passed to
#'   \code{\link{attachDependencies}}.
#'
#' @details Each dependency can be located on the filesystem, at a relative or
#'   absolute URL, or both. The location types are indicated using the names of
#'   the \code{src} character vector: \code{file} for filesystem directory,
#'   \code{href} for URL. For example, a dependency that was both on disk and at
#'   a URL might use \code{src = c(file=filepath, href=url)}.
#'
#'   \code{attachment} can be used to make the indicated files available to the
#'   JavaScript on the page via URL. For each element of \code{attachment}, an
#'   element \code{<link id="DEPNAME-ATTACHINDEX-attachment" rel="attachment"
#'   href="...">} is inserted, where \code{DEPNAME} is \code{name}. The value of
#'   \code{ATTACHINDEX} depends on whether \code{attachment} is named or not; if
#'   so, then it's the name of the element, and if not, it's the 1-based index
#'   of the element. JavaScript can retrieve the URL using something like
#'   \code{document.getElementById(depname + "-" + index + "-attachment").href}.
#'   Note that depending on the rendering context, the runtime value of the href
#'   may be an absolute, relative, or data URI.
#'
#'   \code{htmlDependency} should not be called from the top-level of a package
#'   namespace with absolute paths (or with paths generated by
#'   \code{system.file()}) and have the result stored in a variable. This is
#'   because, when a binary package is built, R will run \code{htmlDependency}
#'   and store the path from the building machine's in the package. This path is
#'   likely to differ from the correct path on a machine that downloads and
#'   installs the binary package. If there are any absolute paths, instead of
#'   calling \code{htmlDependency} at build-time, it should be called at
#'   run-time. This can be done by wrapping the \code{htmlDependency} call in a
#'   function.
#'
#' @seealso Use \code{\link{attachDependencies}} to associate a list of
#'   dependencies with the HTML it belongs with.
#'
#' @export
htmlDependency <- function(name,
                           version,
                           src,
                           meta = NULL,
                           script = NULL,
                           stylesheet = NULL,
                           import= NULL,
                           head = NULL,
                           attachment = NULL,
                           package = NULL,
                           all_files = TRUE) {
  
  # This function shouldn't be called from a namespace environment with
  # absolute paths.
  if (isNamespace(parent.frame()) && any(substr(src, 1, 1) == "/")) {
    warning(
      "htmlDependency shouldn't be called from a namespace environment",
      " with absolute paths (or paths from system.file()).",
      " See ?htmlDependency for more information."
    )
  }
  
  version <- as.character(version)
  validateScalarName(name)
  validateScalarName(version)
  
  srcNames <- names(src)
  if (is.null(srcNames))
    srcNames <- rep.int("", length(src))
  srcNames[!nzchar(srcNames)] <- "file"
  names(src) <- srcNames
  src <- as.list(src)
  
  structure(class = "html_dependency", list(
    name = name,
    version = as.character(version),
    src = src,
    meta = meta,
    script = script,
    stylesheet = stylesheet,
    import = import,
    head = head,
    attachment = attachment,
    package = package,
    all_files = all_files
  ))
}

validateScalarName <- function(x, name = deparse(substitute(x))) {
  if (length(x) != 1 || x == "" || grepl("[/\\]", x)) stop(
    "Invalid argument '", name,
    "' (must be a non-empty character string and contain no '/' or '\\')"
  )
}

#' Create HTML for dependencies
#'
#' Create the appropriate HTML markup for including dependencies in an HTML
#' document.
#'
#' @param dependencies A list of \code{htmlDependency} objects.
#' @param srcType The type of src paths to use; valid values are \code{file} or
#'   \code{href}.
#' @param encodeFunc The function to use to encode the path part of a URL. The
#'   default should generally be used.
#' @param hrefFilter A function used to transform the final, encoded URLs of
#'   script and stylsheet files. The default should generally be used.
#'
#' @return An \code{\link{HTML}} object suitable for inclusion in the head of an
#'   HTML document.
#'
#' @export
renderDependencies <- function(dependencies,
                               srcType = c("href", "file"),
                               encodeFunc = urlEncodePath,
                               hrefFilter = identity) {
  
  html <- c()
  
  for (dep in dependencies) {
    
    usableType <- srcType[which(srcType %in% names(dep$src))]
    if (length(usableType) == 0)
      stop("Dependency ", dep$name, " ", dep$version,
           " does not have a usable source")
    
    dir <- dep$src[head(usableType, 1)]
    
    srcpath <- if (usableType == "file") {
      encodeFunc(dir)
    } else {
      # Assume that href is already URL encoded
      href_path(dep)
    }
    
    # Drop trailing /
    srcpath <- sub("/$", "\\1", srcpath)
    
    # add meta content
    if (length(dep$meta) > 0) {
      html <- c(html, paste(
        "<meta name=\"", htmlEscape(names(dep$meta)), "\" content=\"",
        htmlEscape(dep$meta), "\" />",
        sep = ""
      ))
    }
    
    # add stylesheets
    if (length(dep$stylesheet) > 0) {
      html <- c(html, paste(
        "<link href=\"",
        htmlEscape(hrefFilter(file.path(srcpath, encodeFunc(dep$stylesheet)))),
        "\" rel=\"stylesheet\" />",
        sep = ""
      ))
    }
    
    # add scripts
    if (length(dep$script) > 0) {
      html <- c(html, paste(
        "<script src=\"",
        htmlEscape(hrefFilter(file.path(srcpath, encodeFunc(dep$script)))),
        "\"></script>",
        sep = ""
      ))
    }
    
    # add imports
    if (length(dep$import) > 0) {
      html <- c(html, paste(
        "<link href=\"",
        htmlEscape(hrefFilter(file.path(srcpath, encodeFunc(dep$import)))),
        "\" rel=\"import\" />",
        sep = ""
      ))
    }
    
    if (length(dep$attachment) > 0) {
      if (is.null(names(dep$attachment)))
        names(dep$attachment) <- as.character(1:length(dep$attachment))
      html <- c(html,
                sprintf("<link id=\"%s-%s-attachment\" rel=\"attachment\" href=\"%s\"/>",
                        htmlEscape(dep$name),
                        htmlEscape(names(dep$attachment)),
                        htmlEscape(hrefFilter(file.path(srcpath, encodeFunc(dep$attachment))))
                )
      )
    }
    
    # add raw head content
    html <- c(html, dep$head)
  }
  
  HTML(paste(html, collapse = "\n"))
}


#' @rdname knitr_methods
#' @export
knit_print.shiny.tag <- function(x, ...) {
  x <- htmltools:::tagify(x)
  output <- surroundSingletons(x)
  deps <- resolveDependencies(findDependencies(x, tagify = FALSE), resolvePackageDir = FALSE)
  content <- htmltools:::takeHeads(output)
  head_content <- htmltools:::doRenderTags(tagList(content$head))
  
  meta <- if (length(head_content) > 1 || head_content != "") {
    list(structure(head_content, class = "shiny_head"))
  }
  meta <- c(meta, deps)
  
  knitr::asis_output(
    htmltools:::htmlPreserve(format(content$ui, indent=FALSE)),
    meta = meta)
}